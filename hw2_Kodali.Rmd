---
title: "STAT 4410/8416 Homework 2"
author: "Kodali Akhil"
date: "Due on October 7, 2021"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(fig.align='center', message=FALSE, cache=TRUE)
output <- opts_knit$get("rmarkdown.pandoc.to")
if(!is.null(output)) {
  if(output=="html") opts_chunk$set(out.width = '400px') else
    opts_chunk$set(out.width='.6\\linewidth')
}
```

**1.** The data set `tips` contains tip amounts for different party sizes as well as total bill amounts per payment. We can get the data from the reshape2 package as follows:

```{r}
library(reshape2)
tips.dat <- tips
```

Now answer the following questions:

  a. Compute the tip rate, dividing tip by total bill, and create a new column called `tip.rate` in the dataframe `tips.dat`. Demonstrate your results by showing the head of `tips.dat`.  
  Ans.
```{r}
tips.dat$tip.rate <-with(tips.dat, tip/total_bill)
head(tips.dat)
```
  

  b. Draw a side-by-side violin plot of the tip rate for each party size. Order the party sizes by the median tip rate. Provide your code as well as your plot. Which party size is responsible for the highest median tip rate?  
  
  Ans. The party size 1 will have the highest median tip rate because the violin plot of the party size 1 is higher than
  other plots.
  
```{r}
library(ggplot2)
ggplot(tips.dat,aes(reorder(size, tip.rate, median), tip.rate))+
  geom_violin()+xlab("Party size")
```
  


  c. Generate a similar plot to the one you created in question 2b for each day (instead of party size) and facet by sex and smoker. Is the shape of the violin plot similar for each faceted condition?  
  
  Ans. No, the shape of the violin plot kept on changing for each faceted condition.
```{r}
ggplot(tips.dat, aes(reorder(day, tip.rate, median), tip.rate)) + 
  geom_violin() + facet_grid(sex~smoker) +
  xlab("Days")
```
  
  
  
**2.** We can generate an $n$x$k$ matrix $M$ and a vector $V$ of length $k$ for some specific values of $n$ and $k$ as follows:
```{r}
set.seed(321)
n <- 9
k <- 5
V <- sample(seq(50), size = k, replace = TRUE)
M <- matrix(rnorm(n * k), ncol = k)
M
```


  a. Now, carefully review the following for-loop. Rewrite the code so that you perform the same job without a loop.  
  
  Ans. From the below code when we compare X with sol we get the same results which means that we got the same values.

```{r}
X <- M
for(i in seq(n)) {
  X[i, ] <- round(M[i, ] / V, digits = 4)
}
```
```{r}
sol <- round(t(t(M)/V), 4)
sol
X
```
    
  b. Now do the same experiment for $n=900$ and $k=500$. Which runs faster, your code or the for-loop? Demonstrate this using the function `system.time()`.
  
  Ans. My code took 0.01 seconds more than the for loop code.
```{r}
set.seed(321)
n <- 900
k <- 500
V <- sample(seq(50), size = k, replace = TRUE)
M <- matrix(rnorm(n * k), ncol = k)
X <- M

system.time(for(i in seq(n)) {
  X[i, ] <- round(M[i, ] / V, digits = 4)
})
system.time(sol <- round(t(t(M)/V), 4))
```
  
  
**3.** We want to generate a plot of US arrest data (USArrests). Please provide the detailed codes to answer the following questions.

  a. Obtain USA state boundary coordinates data for generating a USA map using function `map_data()` and store the data in `mdat`. Display the first few rows of data from `mdat`, noticing that there is a column called `order` that contains the true order of the coordinates.
  
  Ans. 
```{r}
library(maps)
mdat <- map_data("state")
head(mdat)
```
  

  b. \label{standardize-rate} You will find USA crime data in the data frame called `USArrests`. Standardize the crime rates and create a new column called `state` so that all state names are in lower case. Store this new data in an object called `arrest` and report the first few rows of `arrest`.  
  
  Ans.
```{r}
scale.dat <- scale(USArrests)
rname <- row.names(USArrests)
state <- tolower(rname)
arrest <- data.frame(state, scale.dat)
head(arrest)

```
  
  c. \label{order-data} Merge the two data sets `mdat` and `arrest` by state name. Note: merging will change the order of the coordinates data. So, order the data back to the original order and store the merged-ordered data in `odat`. Report the first few rows of data from `odat`.
  
  Ans.
```{r}
dat <- merge(mdat,arrest,by.x = 'region', by.y = 'state')
odat <- dat[order(dat$order),]
head(odat)
```
  

  d. All the columns of `odat` are not necessary for our analysis. So, obtain a subset by selecting only the columns long, lat, group, region, Murder, Assault, UrbanPop, and Rape. Store the data in `sdat` and report the first few rows.
  
  Ans.
```{r}
mycol <- c("long", "lat", "group", "region", "Murder", "Assault", "UrbanPop", "Rape" )
sdat <- subset(odat, select = c(mycol))
head(sdat)
```
? subset

  

  e. Melt the data frame `sdat` with id variables long, lat, group, region. Store the molten data in `msdat` and report the first few rows of data.
  
  Ans.
```{r}
msdat <- melt(sdat, id =c("long","lat","group","region") )
  head(msdat)
```

  
  f. \label{plot-crime} The molten data frame `msdat` is now ready to be plotted. Create a plot showing the USA state map, fill by value, and `facet_wrap` with variable. Please don't add any legend and make sure that facetting labels are identified so that we can compare the facetted plots.
  
  Ans.
```{r}
library(scales)
ggplot(msdat, aes(x=long, y=lat,group=group)) +
  geom_polygon(aes(fill=value), colour = alpha("pink", 1/2), size = 0.1) + 
   theme(legend.position = "none") + 
  facet_wrap(~variable) +
  scale_fill_continuous(low="white", high="black") 
```
  
  

  g. Now examine the plot you have generated in question (f) and answer the following questions based on what you see in the plot.  
    \   
    i. For each crime, name two states with its highest rate. 
    
    Ans. 1) Murder is higher in Florida and Gerogia.
         2) Assault is higher in Florida and North Carolina.
         3) UrbanPop is higher in California and New York.
         4) Rape is higher in Arizona and California.
         
    ii. Do you think a larger urban population is indicative of a higher murder rate? Why or why not? 
    
    Ans. No, I dont think so as murder rate is higher in Florida and Georgia. But the population is higher in other states
    which have low murder rate.

  h. In question (3b) we standardized the crime rates. Why do you think we did this? Explain what would happen if we did not standardize the data.
  
  Ans. We standardized the data because it stabilizes the distribution as they use the same scale (Z-score). If we have not
  used the standardization technique, then we may not have got all the light colors for Murder because the values of Murder 
  are very smaller as compared to Assault. This kind of distribution for color may have resulted in getting plot having dark
  colors for Assault and light colors for Murder which is of no use in data analysis.

  i. In question (3c) we ordered the data after merging. Why do you think we had to do this? Explain what would happen if we did not.
  
  Ans. The ordering of the data is important and we need to do this as the map is constructed based on the ordering. If
  we have not done that, then the US map will not be perfect as an exact US map as it might have changed its shape based 
  on random order.

**4.** Life expectancy data for four countries can be obtained from the world bank database found at
[github](http://mamajumder.github.io/data-science/data/life-expectancy.csv). It contains life expectancy in years for different genders. Now answer the following questions. 

  a. Read the data from the above link and display the first few rows of data. 
  
  Ans.
```{r}
lifedat <- read.csv("http://mamajumder.github.io/data-science/data/life-expectancy.csv")
head(lifedat)
```
  

  b. \label{life} Generate a plot showing trend lines of life expectancy by year. Color them by sex and facet by country. Include your code with the plot.
  
  Ans. 
```{r}
meltdat <- melt(lifedat, id=c("year","sex"))
ggplot(meltdat, aes(as.numeric(year), value)) + geom_line(aes(color=sex)) +
  facet_wrap(~variable) + xlab("Year") + ylab("Life expectancy (year)")
```
  

  c. Explain what interesting features you noticed in the plot you made in question 4b.

  Ans. 1) USA has the highest life expectancy than other countries.
       2) Lastest year shows that female have high life expectancy than male. 
       3) There is a ditch in Bangladesh graph, which shows a sudden decrease in life expectancy in Bangladesh
       in early 1970's.
       4) In the early years, in India and Bangladesh, female life expectancy is lower than male but through ages
       it reversed.

**5.** For the following questions please use data frame `tips` 

  a. \label{bar} Create a bar chart that shows the average tip by day.
  
  Ans. 
```{r}
atip <- tapply(tips$tip, tips$day, mean)
barplot(atip,xlab= "Days", ylab="Average Tip", main = "Average Tip per Day")

```
  

  b. Compute the average tip, total tip, and average size grouped by smoker and day. i.e.,  For each combination of smoker and day you should have a row of these summaries. Report these results in a nice table.
  
  Ans.
```{r}
library(dplyr)
summdat <- tips %>%
  group_by(smoker, day) %>%
  summarize(atip = mean(tip),ttip = sum(tip),asize = mean(size))
library(knitr)
kable(summdat, format = 'pipe')
```
  

  c. \label{bar-facet} Create a bar chart that shows average tip by day, faceted by smoker.
  
  Ans.
```{r}
ggplot(summdat, aes(day,sex, atip)) + geom_bar(stat="identity") + 
   facet_wrap(~smoker) + xlab("Day") + ylab("Average Tip") 
```
  
  

  d. In questions 5a and 5c, we plotted a summary of our data which does not show us the whole picture. In practice, we would like to see all of the data. What plot do you suggest would serve a similar purpose to the one in question 5c? In other words, what would be a better plot to show than tips by day, facetted by smoker? Please produce this plot and include your code.
  
  Ans.
```{r}

ggplot(tips, aes(smoker,)) + geom_bar(stat="identity") + 
   facet_wrap(~day) + xlab("Smoker") + ylab("Average Tip") 
summdat
```
  
  
**6.** We have the following data set:

```{r}
myDat <- read.csv("http://mamajumder.github.io/data-science/data/reshape-source.csv")
kable(myDat)
```

We want to reshape the data and produce the following output:

| player|variable |   A|   B|   C|
|------:|:--------|---:|---:|---:|
|      1|walking  | 408| 402| 386|
|      1|cycling  |  43|  31|  41|
|      2|walking  | 373| 404| 422|
|      2|cycling  |  53|  41|  30|
|      3|walking  | 403| 393| 422|
|      3|cycling  |  25|  46|  48|

Provide code that will produce this desired output. Demonstrate your answer by displaying the output as well.

 Ans. 
```{r}
library(reshape2)
library(dplyr)
meltmyDat <- melt(myDat,id=c(1:2))
meltmyDat
desiredtbl <- dcast(meltmyDat,player+variable~track)
kable(desiredtbl, format = 'pipe')
```
 

**7.** **Ordering the factor** In class, we have seen how to order factors. Suppose we have the following data about a certain value obtained during particular months of the year;

```{r}
month <- c("July", "June", "September", "May", "October", "August")
value <- c(35, 72, 14, 23, 60, 105)
df <- data.frame(month, value)
```

Now please do the following:  

  a. Convert the month column of dataframe `df` into a factor column. Demonstrate that it is indeed converted into a factor column.
  
  Ans. We can convert it into factor using factor() as shown below. When we call the function str() it shows the data type 
  of the column through which we can verify whether its a 'factor' or 'Char'. Now we can see that its a 'factor' in
  the structure. 
  
```{r}
df$month <- factor(df$month)
str(df)
```
  

  b. Now generate a bar chart showing the value for different months. 
  
  Ans.
```{r}
library(ggplot2)
ggplot(df, aes(x=month, y=value)) + geom_bar(stat="identity") + 
  labs(x="Month", y="Value")
```
  

  c. Notice the order of the levels of the months is not natural, instead the plot shows the dictionary order. Now, order the bars according to the natural order of the levels of the class (months of the year as they appear in chronological order) and regenerate the bar graph.  
 
  Ans.
  
```{r}
df$month <- factor(df$month, 
                   levels=c("May", "June", "July", "August", "September", "October"))
ggplot(df, aes(month, value)) + geom_bar( stat="identity") + labs(x="Month", y="Value")
```

  
  
**8.** Install the `babynames` package with `install.packages()`. This package includes data from the Social Security Administration about American baby names over a wide range of years. Generate a plot of the reported proportion of babies born with the name Angelica over time. Do you notice anything odd about the plotted data? (Hint: you should) If so, describe the issue and generate a new plot that adjusts for this problem. Make sure you show both plots along with all code that was used to generate them.

```{r}
library(babynames)
babynames.dat <- babynames
newdata <- subset(babynames.dat, name == 'Angelica')
par(mfrow=c(2,1))
plot(newdata$year,newdata$prop)
```


**9.** **Bonus (2 points)** for undergraduates and mandatory for graduate students. Suppose we have a vector of data as follows:

```{r}
myVector <- c(-15, -10, -5, 0, 5, 10, 15, 20)
```

  a. \label{q.tapply} Using the function `tapply()`, separately compute the means of the first three values, next two values, and the last three values of `myVector`. Show your code. Your result should be: -10.0, 2.5, 15.0.
  
  Ans.
```{r}
val <- c(1,1,1,2,2,3,3,3)
result <- tapply(myVector, val,FUN =  mean)
result
```
  

  b. Now repeat question 9a, but instead of computing means, you will compute the sum of squares. Again, show your code. Your result should be: 350, 25, 725. 
  
  Ans.
```{r}
val <- c(1,1,1,2,2,3,3,3)
square <- function(x){
  sum(x**2)}
result <- tapply(myVector, val, FUN = square)
result
```
  






